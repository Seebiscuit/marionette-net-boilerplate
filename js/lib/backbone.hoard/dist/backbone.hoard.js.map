{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 3310367fa75979e8dc46","webpack:///./src/build/backbone.hoard.bundle.js","webpack:///external {\"amd\":\"backbone\",\"commonjs\":\"backbone\",\"commonjs2\":\"backbone\",\"root\":\"Backbone\"}","webpack:///./src/backbone.hoard.js","webpack:///./src/store.js","webpack:///./src/policy.js","webpack:///./src/control.js","webpack:///./src/strategy.js","webpack:///external {\"amd\":\"underscore\",\"commonjs\":\"underscore\",\"commonjs2\":\"underscore\",\"root\":\"_\"}","webpack:///./src/backend.js","webpack:///./src/meta-store.js","webpack:///./src/store-helpers.js","webpack:///./src/lock.js","webpack:///./src/create-strategy.js","webpack:///./src/read-strategy.js","webpack:///./src/update-strategy.js","webpack:///./src/patch-strategy.js","webpack:///./src/delete-strategy.js","webpack:///./src/positive-write-strategy.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,wC;;;;;;;ACtCA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACpBA,gD;;;;;;ACAA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;;;;;;AClCA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,sCAAqC;AACrC;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA,6BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,EAAC;;AAED;;AAEA;;;;;;;ACjGA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,sCAAqC;AACrC;AACA;;AAEA;AACA,6BAA4B;;AAE5B;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;;AAEA;;;;;;;AC3EA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oCAAmC;AACnC;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA,6BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;;AAEA;;;;;;;ACvGA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA;;AAEA;AACA,6BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA,oBAAmB,oCAAoC;AACvD;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA,uBAAsB;AACtB;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA,oDAAmD;AACnD;AACA;AACA;AACA;AACA,EAAC;;AAED;;AAEA;;;;;;;AC7NA,gD;;;;;;ACAA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,EAAC;;AAED;;;;;;;ACrDA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,sCAAqC;AACrC,qBAAoB,yBAAyB;AAC7C;AACA;;;AAGA;AACA,6BAA4B;;AAE5B;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,EAAC;;AAED;AACA;;;;;;;ACtEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP,IAAG;;AAEH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP,IAAG;;AAEH;AACA;AACA;AACA,MAAK;AACL;AACA;;;;;;;ACzCA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,uCAAsC,qBAAqB,EAAE;AAC7D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA,uB;;;;;;ACpHA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA,EAAC;;;;;;;ACZD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,6BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED,uB;;;;;;AClHA;;AAEA;;AAEA,gDAA+C,mBAAmB;;;;;;;ACJlE;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ,IAAG;;AAEH;AACA,uBAAsB;AACtB;AACA,EAAC;;;;;;;ACjBD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAkC,oBAAoB;AACtD;AACA;AACA,EAAC;;AAED,yB;;;;;;AClBA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,IAAG;;AAEH;AACA,EAAC","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"backbone\"), require(\"underscore\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"backbone\", \"underscore\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"backbone\"), require(\"underscore\")) : factory(root[\"Backbone\"], root[\"_\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_7__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 3310367fa75979e8dc46\n **/","'use strict';\n\nvar Backbone = require('backbone');\nvar Hoard = require('../backbone.hoard');\nHoard.Store = require('../store');\nHoard.Policy = require('../policy');\nHoard.Control = require('../control');\nHoard.Strategy = require('../strategy');\n\nif (typeof Promise !== 'undefined') {\n  Hoard.Promise = Promise;\n}\n\nvar previousHoard = Backbone.Hoard;\nBackbone.Hoard = Hoard;\nHoard.noConflict = function () {\n  Backbone.Hoard = previousHoard;\n  return Hoard;\n};\n\nmodule.exports = Hoard;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/build/backbone.hoard.bundle.js\n ** module id = 0\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external {\"amd\":\"backbone\",\"commonjs\":\"backbone\",\"commonjs2\":\"backbone\",\"root\":\"Backbone\"}\n ** module id = 1\n ** module chunks = 0\n **/","'use strict';\n\nvar Backbone = require('backbone');\nvar Backend = require('./backend');\n\nvar Hoard = {\n  VERSION: '0.4.0',\n\n  Promise: function () {\n    throw new TypeError('An ES6-compliant Promise implementation must be provided');\n  },\n\n  backend: new Backend(),\n\n  sync: Backbone.sync,\n\n  Events: Backbone.Events,\n\n  extend: Backbone.Model.extend,\n\n  _proxyExtend: function () {\n    return Hoard.extend.apply(this, arguments);\n  },\n\n  defer: function () {\n    var deferred = {};\n    deferred.promise = new this.Promise(function (resolve, reject) {\n      deferred.resolve = resolve;\n      deferred.reject = reject;\n    });\n    return deferred;\n  }\n};\n\nmodule.exports = Hoard;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/backbone.hoard.js\n ** module id = 2\n ** module chunks = 0\n **/","'use strict';\n\nvar _ = require('underscore');\nvar Hoard = require('./backbone.hoard');\nvar MetaStore = require('./meta-store');\nvar StoreHelpers = require('./store-helpers');\nvar Lock = require('./lock');\n\nvar mergeOptions = ['backend', 'metaStoreClass'];\n\n// Adapt a common interface to a desired storage mechanism (e.g. localStorage, sessionStorage)\n// The interface is asynchronous, to support the use of asynchronous backends (e.g. IndexedDB)\nvar Store = function (options) {\n  _.extend(this, _.pick(options || {}, mergeOptions));\n  _.defaults(this, {\n    backend: Hoard.backend,\n    metaStoreClass: MetaStore\n  });\n  this.metaStore = new this.metaStoreClass(options);\n  this.initialize.apply(this, arguments);\n};\n\n_.extend(Store.prototype, Hoard.Events, {\n  initialize: function () {},\n\n  // Store an item and its metadata\n  // If the store fails to set an item, invalidate the key\n  // and return an error message\n  set: function (key, item, meta, options) {\n    item = item || '';\n    meta = meta || '';\n    return Lock.withAccess('store-write', _.bind(function () {\n      var itemPromise = this.setItem(key, item);\n      var metaPromise = this.metaStore.set(key, meta, options);\n      return Hoard.Promise.all([itemPromise, metaPromise]);\n    }, this)).then(\n      _.identity,\n      _.bind(function (error) {\n        var errorHandler = function () {\n          return Hoard.Promise.reject({\n            key: key,\n            value: item,\n            meta: meta,\n            error: error,\n            options: options\n          });\n        };\n        return this.invalidate(key, options)\n          .then(errorHandler, errorHandler);\n      }, this)\n    );\n  },\n\n  // Retrieve an item from the cache\n  // Returns a promise that resolves with the found cache item\n  // or rejects if an item is not found in the cache\n  get: function (key, options) {\n    return this.getItem.apply(this, arguments);\n  },\n\n  // Remove an item and its metadata from the cache\n  invalidate: function (key, options) {\n    var storePromise = this.removeItem(key, options);\n    var metaPromise = this.metaStore.invalidate(key, options);\n    return Hoard.Promise.all([storePromise, metaPromise]);\n  },\n\n  // Remove all items listed by store metadata then remove all metadata.\n  invalidateAll: function (options) {\n    var dataPromise = this.getAllMetadata(options).then(_.bind(function (metadata) {\n      var removals = _.map(_.keys(metadata), function (key) {\n        return this.removeItem(key, options);\n      }, this);\n\n      return Hoard.Promise.all(removals);\n    }, this));\n    var metaPromise = this.metaStore.invalidateAll(options);\n    return Hoard.Promise.all([dataPromise, metaPromise]);\n  },\n\n  // Get the metadata associated with the given key\n  getMetadata: function (key, options) {\n    return this.metaStore.get(key, options);\n  },\n\n  // Get all the metadata\n  getAllMetadata: function (options) {\n    return this.metaStore.getAll(options);\n  },\n\n  getItem: StoreHelpers.proxyGetItem,\n  setItem: StoreHelpers.proxySetItem,\n  removeItem: StoreHelpers.proxyRemoveItem\n});\n\nStore.extend = Hoard._proxyExtend;\n\nmodule.exports = Store;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/store.js\n ** module id = 3\n ** module chunks = 0\n **/","'use strict';\n\nvar _ = require('underscore');\nvar Hoard = require('./backbone.hoard');\n\nvar mergeOptions = ['expires', 'timeToLive'];\n\n// A Policy determines key generation and cache eviction\nvar Policy = function (options) {\n  _.extend(this, _.pick(options || {}, mergeOptions));\n  this.initialize.apply(this, arguments);\n};\n\n_.extend(Policy.prototype, Hoard.Events, {\n  initialize: function () {},\n\n  // Generate a key for the given model\n  // The key will be used to determine uniqueness in the store\n  getKey: function (model, method, options) {\n    return this.getUrl(model, method, options);\n  },\n\n  // Get the url for the given model\n  getUrl: function (model, method, options) {\n    return _.result(model, 'url');\n  },\n\n  // Get the data from the given model\n  getData: function (model, options) {\n    return model.toJSON();\n  },\n\n  // Get the collection associated with the model\n  getCollection: function (model, options) {\n    return model.collection;\n  },\n\n  // Do two models refer to the same resource?\n  // @param model: the raw model attributes\n  // @param otherModel: the raw model attributes\n  areModelsSame: function (model, otherModel) {\n    return model.id === otherModel.id;\n  },\n\n  // Find the same resource within a collection\n  // @param collection: the raw collection array\n  // @param model: the raw model attributes\n  findSameModel: function (collection, model) {\n    return _.find(collection, function (other) {\n      return this.areModelsSame(model, other);\n    }, this);\n  },\n\n  // Generate metadata\n  // Overwrite to return meaningful metadata\n  getMetadata: function (key, response, options) {\n    return {};\n  },\n\n  // Return true if the item associated with the given metadata should be evicted.\n  // Return false otherwise.\n  // Override if you want to use metaData to determine whether or not to evict the item\n  shouldEvictItem: function (meta) {\n    return false;\n  },\n\n  // Return an array of keys to evict\n  // By default, clear the world\n  getKeysToEvict: function (metadata, key, value, error) {\n    return _.keys(metadata);\n  }\n});\n\nPolicy.extend = Hoard._proxyExtend;\n\nmodule.exports = Policy;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/policy.js\n ** module id = 4\n ** module chunks = 0\n **/","'use strict';\n\nvar _ = require('underscore');\n\nvar Hoard = require('./backbone.hoard');\nvar Store = require('./store');\nvar Policy = require('./policy');\nvar CreateStrategyClass = require('./create-strategy');\nvar ReadStrategyClass = require('./read-strategy');\nvar UpdateStrategyClass = require('./update-strategy');\nvar PatchStrategyClass = require('./patch-strategy');\nvar DeleteStrategyClass = require('./delete-strategy');\n\n// Configuration information to ease the creation of Strategy classes\nvar strategies = {\n  create: {\n    klass: CreateStrategyClass,\n    classProperty: 'createStrategyClass',\n    property: 'createStrategy'\n  },\n\n  read: {\n    klass: ReadStrategyClass,\n    classProperty: 'readStrategyClass',\n    property: 'readStrategy'\n  },\n\n  update: {\n    klass: UpdateStrategyClass,\n    classProperty: 'updateStrategyClass',\n    property: 'updateStrategy'\n  },\n\n  patch: {\n    klass: PatchStrategyClass,\n    classProperty: 'patchStrategyClass',\n    property: 'patchStrategy'\n  },\n\n  'delete': {\n    klass: DeleteStrategyClass,\n    classProperty: 'deleteStrategyClass',\n    property: 'deleteStrategy'\n  }\n};\n\nvar mergeOptions = _.union(['storeClass', 'policyClass'],\n  _.pluck(strategies, 'classProperty'));\n\nvar strategyClasses = {};\n_.each(strategies, function (strategy) {\n  strategyClasses[strategy.classProperty] = strategy.klass;\n});\n\n// A Control is the entry point for caching behavior.\n// It serves as a means of grouping the configured Store, Policy, and Strategies,\n// all of which contain the main caching logic\nvar Control = function (options) {\n  _.extend(this, _.pick(options || {}, mergeOptions));\n  var defaultClasses = _.extend({\n    storeClass: Store,\n    policyClass: Policy\n  }, strategyClasses);\n  _.defaults(this, defaultClasses);\n\n  // Create and assign a store and policy\n  this.store = new this.storeClass(options);\n  this.policy = new this.policyClass(options);\n\n  // For each sync method, create and assign a strategy to this Control\n  // Each strategy has access to this Control's store and policy\n  var strategyOptions = _.extend({}, options, {\n    store: this.store,\n    policy: this.policy\n  });\n  _.each(strategies, function (strategy) {\n    this[strategy.property] = new this[strategy.classProperty](strategyOptions);\n  }, this);\n\n  this.initialize.apply(this, arguments);\n};\n\n_.extend(Control.prototype, Hoard.Events, {\n  initialize: function () {},\n\n  // For the given sync method, execute the matching Strategy\n  sync: function (method, model, options) {\n    var strategyProperty = strategies[method].property;\n    var strategy = this[strategyProperty];\n    return strategy.execute(model, options);\n  },\n\n  // The main use of Hoard\n  // Return a sync method fully configured for the cache behavior of this Control\n  getModelSync: function () {\n    var modelSync = _.bind(this.sync, this);\n    modelSync.hoardControl = this;\n    return modelSync;\n  }\n});\n\nControl.extend = Hoard._proxyExtend;\n\nmodule.exports = Control;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/control.js\n ** module id = 5\n ** module chunks = 0\n **/","'use strict';\n\nvar _ = require('underscore');\nvar Hoard = require('./backbone.hoard');\nvar Lock = require('./lock');\n\nvar mergeOptions = ['store', 'policy'];\n\n// A Strategy is tied to a particular sync method on a Control\n// The execute method will be called by the Control with the model and options being synced.\n// It is abstract by default, and it's implementations get access to the Store and Policy\n// provided by the Controller\nvar Strategy = function (options) {\n  _.extend(this, _.pick(options || {}, mergeOptions));\n  this.initialize.apply(this, arguments);\n};\n\n_.extend(Strategy.prototype, Hoard.Events, {\n  initialize: function () {},\n\n  // Set up some configuration, and pass control to this strategy's sync method\n  // Take care of all caching/server requesting.\n  // This is the main strategy method and entry point from Hoard.Control\n  execute: function (model, options) {\n    var hoardOptions = this.decorateOptions(model, options);\n    return this.sync(model, hoardOptions);\n  },\n\n  // If the model belongs to a collection and that collection is cached,\n  //   first try to read the model from the collection's cache\n  // Default to getting it from the model's cache\n  get: function (key, options) {\n    var updateCollection = this._getUpdateCollection(options);\n    var getFromCache = _.bind(this.store.get, this.store, key, options);\n    if (updateCollection) {\n      return updateCollection().then(\n        function (collection) {\n          var modelResponse = collection.policy.findSameModel(collection.raw, options.model);\n          return modelResponse ? modelResponse : getFromCache();\n        },\n        getFromCache\n      );\n    } else {\n      return getFromCache();\n    }\n  },\n\n  // If the model belongs to a collection and that collection is cached,\n  //   add the model to the collection's cache\n  // Default to setting the model the model's cache\n  set: function (key, value, meta, options) {\n    var updateCollection = this._getUpdateCollection(options);\n    var setToCache = _.bind(this.store.set, this.store, key, value, meta, options);\n    if (updateCollection) {\n      return updateCollection().then(\n        function (collection) {\n          var modelResponse = collection.policy.findSameModel(collection.raw, options.model);\n          if (!modelResponse) {\n            modelResponse = {};\n            collection.raw.push(modelResponse);\n          }\n          // clear the existing model and replace it with the response\n          _.each(_.keys(modelResponse), function (key) {\n            delete modelResponse[key];\n          });\n          _.extend(modelResponse, value);\n          meta = collection.control.policy.getMetadata(collection.key, collection.raw, options);\n          return collection.control.store.set(collection.key, collection.raw, meta, options);\n        },\n        setToCache\n      );\n    } else {\n      return setToCache();\n    }\n  },\n\n  // If the model belongs to a collection and that collection is cached,\n  //   remove the model from the collection's cache\n  // Default to removing the model the model's cache\n  invalidate: function (key, options) {\n    var updateCollection = this._getUpdateCollection(options);\n    var invalidateFromCache = _.bind(this.store.invalidate, this.store, key, options);\n    if (updateCollection) {\n      return updateCollection().then(\n        function (collection) {\n          var filteredCollection = _.reject(collection.raw, function (model) {\n            return collection.policy.areModelsSame(options.model, model);\n          });\n          var meta = collection.control.policy.getMetadata(collection.key, filteredCollection, options);\n          return collection.control.store.set(collection.key, filteredCollection, meta, options);\n        },\n        invalidateFromCache\n      );\n    } else {\n      return invalidateFromCache();\n    }\n  },\n\n  // Return a funtion that accesses the model's collection, if it exists\n  // Otherwise, return undefined, becasues the collection cannot be accessed\n  _getUpdateCollection: function (options) {\n    var collection = options && options.collection;\n    var collectionControl = collection && collection.sync && collection.sync.hoardControl;\n    if (collection && collectionControl) {\n      var collectionKey = collectionControl.policy.getKey(collection, options);\n      return _.bind(function () {\n        return this.store.get(collectionKey, options).then(function (rawCollection) {\n          return {\n            control: collectionControl,\n            policy: collectionControl.policy,\n            key: collectionKey,\n            raw: rawCollection\n          };\n        });\n      }, this);\n    }\n  },\n\n  //When the cache is full, evict items from the cache\n  //and try to store the item again\n  //or just return the value if storage fails\n  onCacheFull: function (cacheFull) {\n    var key = cacheFull.key;\n    var value = cacheFull.value;\n    var meta = cacheFull.meta;\n    var error = cacheFull.error;\n    var options = cacheFull.options;\n\n    // lock access to keep knowledge of cache consistent\n    return Lock.withLock('store-write', _.bind(function () {\n      return this.store.getAllMetadata().then(_.bind(function (metadata) {\n        var keysToEvict = this.policy.getKeysToEvict(metadata, key, value, error);\n        if (!_.isEmpty(keysToEvict)) {\n          var evictions = _.map(keysToEvict, function (key) {\n            return this.invalidate(key, options);\n          }, this);\n          return Hoard.Promise.all(evictions);\n        } else {\n          return Hoard.Promise.reject();\n        }\n      }, this));\n    }, this)).then(\n      _.bind(this.set, this, key, value, meta, options),\n      function () { return Hoard.Promise.reject(value); }\n    );\n  },\n\n  // Override to edit the response\n  // Returns the same response by default\n  decorateResponse: function (response, options) {\n    return response;\n  },\n\n  decorateOptions: function (model, options) {\n    return _.extend({}, options, {\n      url: this.policy.getUrl(model, this.method, options),\n      collection: this.policy.getCollection(model, options),\n      model: model\n    });\n  },\n\n  // Cache the response when the success callback is called\n  _wrapSuccessWithCache: function (method, model, options) {\n    return this._wrapMethod(method, model, _.extend({\n      targetMethod: 'success',\n      responseHandler: _.bind(this._storeResponse, this)\n    }, options));\n  },\n\n  // invalidate the key when the success callback is called\n  _wrapErrorWithInvalidate: function (method, model, options) {\n    return this._wrapMethod(method, model, _.extend({\n      targetMethod: 'error',\n      responseHandler: _.bind(this._invalidateResponse, this)\n    }, options));\n  },\n\n  _wrapMethod: function (method, model, options) {\n    var key = this.policy.getKey(model, method, options);\n    return _.wrap(options[options.targetMethod], _.bind(function (targetMethod, response) {\n      if (targetMethod) {\n        targetMethod(response);\n      }\n      if (options.generateKeyFromResponse) {\n        key = this.policy.getKey(model, method, options);\n      }\n      if (options.responseHandler) {\n        options.responseHandler(key, response, options);\n      }\n    }, this));\n  },\n\n  _invalidateResponse: function (key, response, options) {\n    this.invalidate(key).then(\n      this._storeAction('onStoreSuccess', options, response),\n      this._storeAction('onStoreError', options, response)\n    );\n  },\n\n  _storeResponse: function (key, response, options) {\n    var meta = this.policy.getMetadata(key, response, options);\n    var finalResponse = this.decorateResponse(response, options);\n    this.set(key, finalResponse, meta, options).then(\n      _.identity,\n      _.bind(this.onCacheFull, this)\n    ).then(\n      this._storeAction('onStoreSuccess', options, response),\n      this._storeAction('onStoreError', options, response)\n    );\n  },\n\n  _storeAction: function (method, options, response) {\n    var callback = options[method] || function () { return response };\n    return function () {\n      return callback(response);\n    };\n  }\n});\n\nStrategy.extend = Hoard._proxyExtend;\n\nmodule.exports = Strategy;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/strategy.js\n ** module id = 6\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_7__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external {\"amd\":\"underscore\",\"commonjs\":\"underscore\",\"commonjs2\":\"underscore\",\"root\":\"_\"}\n ** module id = 7\n ** module chunks = 0\n **/","'use strict';\n\nvar _ = require('underscore');\n\n// Mimic the API of localStorage\n// All operations expect JSON strings to be stored and returned\nvar Backend = function () {\n  this.clear();\n};\n\n_.extend(Backend.prototype, {\n  // around 5MB, matching common localStorage limit\n  maxSize: 5000000,\n\n  // Store the given value and update the size\n  setItem: function (key, value) {\n    if (this.size + value.length > this.maxSize) {\n      // Notify Hoard that the cache is full.\n      // This will trigger a cache invalidation.\n      throw new Error(\"On-Page Cache size exceeded\");\n    } else {\n      this.storage[key] = value;\n      this.size += value.length;\n    }\n  },\n\n  // Get the item with the given key from the cache\n  // or null if the item is not found\n  getItem: function (key) {\n    var value = this.storage[key];\n    if (_.isUndefined(value)) {\n      value = null;\n    }\n    return value;\n  },\n\n  // Remove the item with the given key\n  // And update the size of the cache\n  removeItem: function (key) {\n    var value = this.getItem(key);\n    delete this.storage[key];\n    if (value != null) {\n      this.size -= value.length;\n    }\n    return value;\n  },\n\n  clear: function () {\n    this.storage = {};\n    this.size = 0;\n  }\n});\n\nmodule.exports = Backend;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/backend.js\n ** module id = 8\n ** module chunks = 0\n **/","'use strict';\n\nvar _ = require('underscore');\nvar Hoard = require('./backbone.hoard');\nvar StoreHelpers = require('./store-helpers');\n\nvar mergeOptions = ['backend', 'key'];\n\n// The meta store stores all metadata about items in a single entry in the backend.\n// A single entry is used so we can easily iterate over managed keys\n// This API should currently be considered private\nvar MetaStore = function (options) {\n  _.extend(this, _.pick(options || {}, mergeOptions));\n  _.defaults(this, { backend: Hoard.backend });\n  this.initialize.apply(this, arguments);\n};\n\n\n_.extend(MetaStore.prototype, Hoard.Events, {\n  initialize: function () {},\n\n  key: 'backbone.hoard.metastore',\n\n  set: function (key, meta, options) {\n    return this._get(options).then(_.bind(function (allMetadata) {\n      allMetadata[key] = meta;\n      return this._set(this.key, allMetadata);\n    }, this));\n  },\n\n  get: function (key, options) {\n    return this._get(options).then(_.bind(function (allMetadata) {\n      return allMetadata[key] || {};\n    }, this));\n  },\n\n  getAll: function (options) {\n    return this._get(options);\n  },\n\n  invalidate: function (key, options) {\n    return this._get(options).then(_.bind(function (allMetadata) {\n      delete allMetadata[key];\n      return this._set(this.key, allMetadata);\n    }, this));\n  },\n\n  invalidateAll: function (options) {\n    return this.removeItem(this.key, options);\n  },\n\n  _get: function (options) {\n    return this.getItem(this.key, options).then(\n      _.identity,\n      function () {\n        return {};\n      }\n    );\n  },\n\n  _set: function (key, meta) {\n    return this.setItem(key, meta);\n  },\n\n  getItem: StoreHelpers.proxyGetItem,\n  setItem: StoreHelpers.proxySetItem,\n  removeItem: StoreHelpers.proxyRemoveItem\n});\n\nMetaStore.extend = Hoard._proxyExtend;\nmodule.exports = MetaStore;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/meta-store.js\n ** module id = 9\n ** module chunks = 0\n **/","'use strict';\n\nvar Hoard = require('./backbone.hoard');\nvar _ = require('underscore');\n\n// Convenience methods for stores\nmodule.exports = {\n  proxySetItem: function (key, value) {\n    return Hoard.Promise.resolve()\n      .then(_.bind(function () {\n        try {\n          return this.backend.setItem(key, JSON.stringify(value));\n        } catch (e) {\n          return Hoard.Promise.reject(e);\n        }\n      }, this))\n      .then(function () {\n        return value;\n      });\n  },\n\n  proxyGetItem: function (key, options) {\n    return Hoard.Promise.resolve()\n      .then(_.bind(function () {\n        return this.backend.getItem(key);\n      }, this))\n      .then(function (raw) {\n        var storedValue = JSON.parse(raw);\n        if (storedValue !== null) {\n          return storedValue;\n        } else {\n          return Hoard.Promise.reject();\n        }\n      });\n  },\n\n  proxyRemoveItem: function (key, options) {\n    return Hoard.Promise.resolve().then(_.bind(function () {\n      return this.backend.removeItem(key);\n    }, this));\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/store-helpers.js\n ** module id = 10\n ** module chunks = 0\n **/","'use strict';\n\nvar _ = require('underscore');\nvar Hoard = require('./backbone.hoard');\n\n// Internal store to keep track of state of locks\n// Keyed by lock name\n// Stores promises indicating lock access and acquisition\nvar locks = {};\n\n// Get lock with name lockName if it exists\n// Create it and return it if it doesn't exist\nvar getLock = function (lockName) {\n  var lock = locks[lockName];\n  if (!lock) {\n    lock = {\n      accesses: {}\n    };\n    locks[lockName] = lock;\n  }\n  return lock;\n};\n\n// Return a promise that resolves when all provided promises have either passed or succeeded\n// This differs from Promise.all in that it will not fail immediately if any of the given promises fail\n// and will instead fail once all promises have completed\nvar allPromisesComplete = function (promises) {\n  var finalPromise = Hoard.Promise.resolve;\n  var allPromise = _.reduce(promises, function (memo, promise) {\n    var pass = function () { return promise; };\n    var fail = function () {\n      finalPromise = Hoard.Promise.reject();\n      return promise;\n    };\n    return memo.then(pass, fail);\n  }, Hoard.Promise.resolve());\n  return allPromise.then(function () { return finalPromise; });\n};\n\n// A helper function to wrap a callback with the context of lock access\n// Lock access context is maintained to allow access nested within a lock call\nvar callWithLockContext = function (lock, isInsideLock, callback) {\n  return function () {\n    lock.isInsideLock = isInsideLock;\n    var value = callback();\n    delete lock.isInsideLock;\n    return value;\n  };\n};\n\n// A utility method to execute a callback\n// And pass through the failure\nvar rejectCallback = function (callback) {\n  return function (failure) {\n    var value = callback(failure);\n    return Hoard.Promise.reject(value);\n  };\n};\n\n// A set of methods to\n// (1) provide exclusive access to a resource\n// (2) provide unbounded access to a resource in the absence of any exclusive access\n// This allows normal method behavior, until mutex behavior is needed\n// Resources are identified by the lockName\nvar Lock = {\n  // Acquires lock with name lockName if lock is not already acquired or being accessed\n  // Otherwise, waits until lock is available\n  withLock: function (lockName, callback) {\n    var lock = getLock(lockName);\n    var lockLater = _.bind(this.withLock, this, lockName, callback);\n\n    if (lock.locked) {\n      return lock.locked.then(lockLater, rejectCallback(lockLater));\n    } else if (!_.isEmpty(lock.accesses)) {\n      return allPromisesComplete(lock.accesses).then(lockLater, rejectCallback(lockLater));\n    } else {\n      var cleanLock = function (value) {\n        delete lock.locked;\n        return value;\n      };\n      var acquiredLock = Hoard.Promise.resolve()\n        .then(callWithLockContext(lock, true, callback))\n        .then(cleanLock, rejectCallback(cleanLock));\n      lock.locked = acquiredLock;\n      return acquiredLock;\n    }\n  },\n\n  // Accesses lock with name lockName if lock is not already acquired\n  // Otherwise, waits until lock is available\n  withAccess: function (lockName, callback) {\n    var lock = getLock(lockName);\n    if (lock.locked && !lock.isInsideLock) {\n      var accessLater = _.bind(this.withAccess, this, lockName, callback);\n      return lock.locked.then(accessLater, rejectCallback(accessLater));\n    } else {\n      var accessId = _.uniqueId('backbone.hoard.lock.access_');\n      var cleanLock = function (value) {\n        delete lock.accesses[accessId];\n        return value;\n      };\n      var access = Hoard.Promise.resolve()\n        .then(callWithLockContext(lock, lock.isInsideLock, callback))\n        .then(cleanLock, rejectCallback(cleanLock));\n      lock.accesses[accessId] = access;\n      return access;\n    }\n  },\n\n  // Remove a lock\n  // Only to be used for testing\n  __resetLock: function (lockName) {\n    delete locks[lockName];\n  }\n};\n\nmodule.exports = Lock;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/lock.js\n ** module id = 11\n ** module chunks = 0\n **/","'use strict';\n\nvar PositiveWriteStrategy = require('./positive-write-strategy');\n\nmodule.exports = PositiveWriteStrategy.extend({\n  method: 'create',\n\n  // In standard REST APIs, the id is not available until the response returns.\n  // Therefore, use the response when determining how to cache.\n  cacheOptions: function (model, options) {\n    return { generateKeyFromResponse: true };\n  }\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/create-strategy.js\n ** module id = 12\n ** module chunks = 0\n **/","'use strict';\n\nvar _ = require('underscore');\nvar Hoard = require('./backbone.hoard');\nvar Strategy = require('./strategy');\n\n// The `Read` Strategy keeps a hash, `this.placeholders` of cache keys for which it is currently retrieving data.\n// Only one request, the 'live' request, for a given key will actually go through to retrieve the data from its source,\n// be it a cache hit (read from storage), or a cache miss (read from the server).\n// The remaining requests, the 'placeholder' requests', will receive the data once the live request responds.\nvar Read = Strategy.extend({\n  method: 'read',\n\n  initialize: function (options) {\n    this.placeholders = {};\n  },\n\n  sync: function (model, options) {\n    var key = this.policy.getKey(model, this.method, options);\n\n    // If a placeholder is hit, then a request has already been made for this key\n    // Resolve when that request has returned\n    if (this.placeholders[key]) {\n      return this._onPlaceholderHit(key, options);\n    } else {\n      // If a placeholder is not found, then check the store for that key\n      // If the key is found in the store, treat that as a cache hit\n      // Otherwise, treat that as a cache miss\n      var executionPromise = this.get(key, options).then(\n        _.bind(this.onCacheHit, this, key, model, options),\n        _.bind(this.onCacheMiss, this, key, model, options)\n      );\n\n      // This is the first access, add a placeholder to signify that this key is in the process of being fetched\n      // `accesses` refers to the number of current live requests for this key\n      // `promise` will be resolved with the key's data if the retrieval is successful,\n      // or rejected with an error otherwise\n      this.placeholders[key] = {\n        accesses: 1,\n        promise: executionPromise\n      };\n\n      return executionPromise;\n    }\n  },\n\n  // On a cache hit, first check to see if the cached item should be evicted (e.g. the cache has expired).\n  // If the item should be evicted, do so, and proceed as a cache miss.\n  // Otherwise, remove this request from the placeholder access and resolve the promise with the cached item\n  onCacheHit: function (key, model, options, cachedItem) {\n    return this.store.getMetadata(key, options).then(_.bind(function (meta) {\n      if (this.policy.shouldEvictItem(meta)) {\n        return this.invalidate(key).then(_.bind(function () {\n          return this.onCacheMiss(key, model, options);\n        }, this));\n      } else {\n        this._decreasePlaceholderAccess(key);\n        if (options.success) {\n          options.success(cachedItem);\n        }\n        return cachedItem;\n      }\n    }, this));\n  },\n\n  // On a cache miss, fetch the data using `Hoard.sync` and cache it on success/invalidate on failure.\n  // Clears it's placeholder access only after storing or invalidating the response\n  onCacheMiss: function (key, model, options) {\n    var deferred = Hoard.defer();\n    var callback = _.bind(function (response) {\n      this._decreasePlaceholderAccess(key);\n      return deferred.resolve(response);\n    }, this);\n\n    var cacheOptions = _.extend({\n      onStoreSuccess: callback,\n      onStoreError: callback\n    }, options);\n    options.success = this._wrapSuccessWithCache(this.method, model, cacheOptions);\n    options.error = this._wrapErrorWithInvalidate(this.method, model, cacheOptions);\n\n    var syncResponse = Hoard.sync(this.method, model, options);\n    return deferred.promise.then(function () {\n      return syncResponse;\n    });\n  },\n\n  // On a placeholder hit, wait for the live request to go through,\n  // then resolve or reject with the response from the live request\n  _onPlaceholderHit: function (key, options) {\n    var deferred = Hoard.defer();\n    var callback = function (promiseHandler, originalHandler, response) {\n      if (originalHandler) { originalHandler(response); }\n      this._decreasePlaceholderAccess(key);\n      promiseHandler(response);\n    };\n    var onSuccess = _.bind(callback, this, deferred.resolve, options.success);\n    var onError = _.bind(callback, this, deferred.reject, options.error);\n\n    this.placeholders[key].accesses += 1;\n    this.placeholders[key].promise.then(onSuccess, onError);\n    return deferred.promise;\n  },\n\n  // A convenience method for decrementing the count for a placeholder\n  // and deleting the placeholder if nothing is currently accessing it\n  _decreasePlaceholderAccess: function (key) {\n    this.placeholders[key].accesses -= 1;\n    if (!this.placeholders[key].accesses) {\n      delete this.placeholders[key];\n    }\n  }\n});\n\nmodule.exports = Read;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/read-strategy.js\n ** module id = 13\n ** module chunks = 0\n **/","'use strict';\n\nvar PositiveWriteStrategy = require('./positive-write-strategy');\n\nmodule.exports = PositiveWriteStrategy.extend({ method: 'update' });\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/update-strategy.js\n ** module id = 14\n ** module chunks = 0\n **/","'use strict';\n\nvar PositiveWriteStrategy = require('./positive-write-strategy');\nvar _ = require('underscore');\n\nmodule.exports = PositiveWriteStrategy.extend({\n  method: 'patch',\n\n  // A reasonable response for a PATCH call is to return the delta of the update.\n  // Provide the original information so the cached data makes sense\n  cacheOptions: function (model, options) {\n    return { original: this.policy.getData(model, options) };\n  },\n\n  decorateResponse: function (response, options) {\n    return _.extend({}, options.original, response);\n  }\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/patch-strategy.js\n ** module id = 15\n ** module chunks = 0\n **/","'use strict';\n\nvar Hoard = require('./backbone.hoard');\nvar Strategy = require('./strategy');\n\n// The Delete Strategy aggressively clears a cached item\nvar Delete = Strategy.extend({\n  method: 'delete',\n\n  sync: function (model, options) {\n    var key = this.policy.getKey(model, this.method);\n    var invalidatePromise = this.invalidate(key, options);\n    var syncPromise = Hoard.sync(this.method, model, options);\n    var returnSync = function () { return syncPromise; };\n    return invalidatePromise.then(returnSync);\n  }\n});\n\nmodule.exports = Delete;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/delete-strategy.js\n ** module id = 16\n ** module chunks = 0\n **/","'use strict';\n\nvar _ = require('underscore');\nvar Hoard = require('./backbone.hoard');\nvar Strategy = require('./strategy');\n\n// A strategy for caching a successful response. Subclasses declare a sync method to adhere use\nmodule.exports = Strategy.extend({\n  // Cache the response.\n  // If cacheOptions.generateKeyFromResponse is true,\n  // cache using the key from the response, rather than the request\n  sync: function (model, options) {\n    // Don't consider the sync 'complete' until storage is also complete\n    // This ensures that the cache is in sync with the server\n    var storeComplete = Hoard.defer();\n    var cacheOptions = _.extend({\n      onStoreSuccess: storeComplete.resolve,\n      onStoreError: storeComplete.reject\n    }, options, this.cacheOptions(model, options));\n\n    options.success = this._wrapSuccessWithCache(this.method, model, cacheOptions);\n    Hoard.sync(this.method, model, options);\n    return storeComplete.promise;\n  },\n\n  cacheOptions: function (model, options) {}\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/positive-write-strategy.js\n ** module id = 17\n ** module chunks = 0\n **/"],"sourceRoot":"","file":"backbone.hoard.js"}